/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 1 "poet_pthread.h"
typedef unsigned long pthread_t;
#line 3 "poet_pthread.h"
struct __anonstruct_pthread_mutex_t_1 {
   int volatile   value ;
};
#line 3 "poet_pthread.h"
typedef struct __anonstruct_pthread_mutex_t_1 pthread_mutex_t;
#line 18 "poet_pthread.h"
typedef unsigned long pthread_mutexattr_t;
#line 19 "poet_pthread.h"
union __anonunion_pthread_attr_t_2 {
   char __size[56] ;
   long __align ;
};
#line 19 "poet_pthread.h"
typedef union __anonunion_pthread_attr_t_2 pthread_attr_t;
#line 23
extern int pthread_create(pthread_t *thread , pthread_attr_t const   *attr , void *(*start_routine)(void * ) ,
                          void *arg ) ;
#line 25
extern int pthread_mutex_init(pthread_mutex_t *lock , pthread_mutexattr_t const   *a ) ;
#line 26
extern int pthread_mutex_lock(pthread_mutex_t *lock ) ;
#line 27
extern int pthread_mutex_unlock(pthread_mutex_t *lock ) ;
#line 9 "verifier-poet.h"
extern void __VERIFIER_error() ;
#line 10
extern int __VERIFIER_nondet_int(int  , int  ) ;
#line 11 "atgc-count.c"
pthread_mutex_t mutexid  ;
#line 12 "atgc-count.c"
pthread_mutex_t mutexdone  ;
#line 13 "atgc-count.c"
pthread_mutex_t mutexres  ;
#line 14 "atgc-count.c"
int idcount  =    0;
#line 15 "atgc-count.c"
int donecount  =    0;
#line 16 "atgc-count.c"
int result[2]  ;
#line 17 "atgc-count.c"
int target  ;
#line 18 "atgc-count.c"
int sequence[6]  ;
#line 20
void *thread(void *arg ) ;
#line 63
int main(void) ;
#line 63 "atgc-count.c"
int main(void) 
{ 
  int i ;
  pthread_t t[2] ;
  int count ;

  {
#line 76
  i = 0;
#line 76
  while (i < 6) {
#line 78
    sequence[i] = __VERIFIER_nondet_int(0, 3);
#line 76
    i ++;
  }
#line 83
  target = __VERIFIER_nondet_int(0, 3);
#line 86
  pthread_mutex_init(& mutexid, (pthread_mutexattr_t const   *)((void *)0));
#line 87
  pthread_mutex_init(& mutexdone, (pthread_mutexattr_t const   *)((void *)0));
#line 88
  pthread_mutex_init(& mutexres, (pthread_mutexattr_t const   *)((void *)0));
#line 89
  i = 0;
#line 89
  while (i < 2) {
#line 89
    result[i] = 0;
#line 89
    i ++;
  }
#line 92
  i = 0;
#line 93
  i = 0 + 1;
#line 94
  pthread_create(& t[i], (pthread_attr_t const   *)((void *)0), & thread, (void *)0);
#line 95
  i ++;
#line 96
  pthread_create(& t[i], (pthread_attr_t const   *)((void *)0), & thread, (void *)0);
#line 97
  if (! (i == 2)) {
#line 97
    __VERIFIER_error();
  }
#line 110
  pthread_mutex_lock(& mutexdone);
#line 111
  i = donecount;
#line 112
  pthread_mutex_unlock(& mutexdone);
#line 114
  if (i != 2) {
#line 116
    return (0);
  }
#line 121
  count = 0;
#line 122
  i = 0;
#line 122
  while (i < 2) {
#line 125
    count += result[i];
#line 122
    i ++;
  }
#line 129
  if (! (count >= 0)) {
#line 129
    __VERIFIER_error();
  }
#line 131
  if (! (count <= 6)) {
#line 131
    __VERIFIER_error();
  }
#line 133
  return (0);
}
}
#line 20 "atgc-count.c"
void *thread(void *arg ) 
{ 
  int id ;
  int i ;
  int count ;

  {
#line 25
  pthread_mutex_lock(& mutexid);
#line 26
  id = idcount;
#line 27
  idcount ++;
#line 28
  pthread_mutex_unlock(& mutexid);
#line 29
  if (! (id >= 0)) {
#line 29
    __VERIFIER_error();
  }
#line 31
  if (! (id <= 2)) {
#line 31
    __VERIFIER_error();
  }
#line 36
  count = 0;
#line 37
  i = 0;
#line 37
  while (i < 3) {
#line 39
    if (sequence[id * 3 + i] == target) {
#line 41
      count ++;
    }
#line 43
    if (count > 3) {
#line 45
      count = 3;
    }
#line 37
    i ++;
  }
#line 51
  pthread_mutex_lock(& mutexres);
#line 52
  result[id] = count;
#line 53
  pthread_mutex_unlock(& mutexres);
#line 56
  pthread_mutex_lock(& mutexdone);
#line 57
  donecount ++;
#line 58
  pthread_mutex_unlock(& mutexdone);
#line 60
  return ((void *)0);
}
}

/* done: 24 globals */

