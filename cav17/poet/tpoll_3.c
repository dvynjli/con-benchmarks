/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 1 "poet_pthread.h"
typedef unsigned long pthread_t;
#line 3 "poet_pthread.h"
struct __anonstruct_pthread_mutex_t_1 {
   int volatile   value ;
};
#line 3 "poet_pthread.h"
typedef struct __anonstruct_pthread_mutex_t_1 pthread_mutex_t;
#line 18 "poet_pthread.h"
typedef unsigned long pthread_mutexattr_t;
#line 19 "poet_pthread.h"
union __anonunion_pthread_attr_t_2 {
   char __size[56] ;
   long __align ;
};
#line 19 "poet_pthread.h"
typedef union __anonunion_pthread_attr_t_2 pthread_attr_t;
#line 23
extern int pthread_create(pthread_t *thread , pthread_attr_t const   *attr , void *(*start_routine)(void * ) ,
                          void *arg ) ;
#line 24
extern int pthread_join(pthread_t thread , void **arg ) ;
#line 25
extern int pthread_mutex_init(pthread_mutex_t *lock , pthread_mutexattr_t const   *a ) ;
#line 27
extern int pthread_mutex_lock(pthread_mutex_t *lock ) ;
#line 28
extern int pthread_mutex_unlock(pthread_mutex_t *lock ) ;
#line 9 "verifier-poet.h"
extern void __VERIFIER_error() ;
#line 10
extern int __VERIFIER_nondet_int(int  , int  ) ;
#line 9 "sorting_3.c"
int source[30]  ;
#line 10 "sorting_3.c"
int minBound[3]  ;
#line 11 "sorting_3.c"
int maxBound[3]  ;
#line 12 "sorting_3.c"
int channel[3]  ;
#line 13 "sorting_3.c"
int th_id  =    0;
#line 15 "sorting_3.c"
pthread_mutex_t mid  ;
#line 16 "sorting_3.c"
pthread_mutex_t ms[3]  ;
#line 35
void *sort_thread(void *arg ) ;
#line 71
int main(void) ;
#line 71 "sorting_3.c"
int main(void) 
{ 
  int _cil14 ;
  int _cil12 ;
  int _cil10 ;
  pthread_t t[3] ;
  int i ;
  int j ;
  int k ;

  {
#line 79
  i = __VERIFIER_nondet_int(0, 29);
#line 80
  source[i] = __VERIFIER_nondet_int(0, 20);
#line 83
  if (! (source[i] >= 0)) {
#line 83
    __VERIFIER_error();
  }
#line 86
  pthread_mutex_init(& mid, (pthread_mutexattr_t const   *)((void *)0));
#line 89
  j = 0;
#line 93
  if (! (10 >= 1)) {
#line 93
    __VERIFIER_error();
  }
#line 96
  i = 0;
#line 105
  channel[0] = 0;
#line 105
  minBound[0] = 0;
#line 105
  maxBound[0] = (0 + 10) - 1;
#line 105
  j = 0 + 10;
#line 105
  pthread_mutex_init(& ms[0], (pthread_mutexattr_t const   *)((void *)0));
#line 105
  pthread_create(& t[0], (pthread_attr_t const   *)((void *)0), & sort_thread, (void *)0);
#line 105
  i = 0 + 1;
#line 106
  channel[i] = 0;
#line 106
  minBound[i] = j;
#line 106
  maxBound[i] = (j + 10) - 1;
#line 106
  j += 10;
#line 106
  pthread_mutex_init(& ms[i], (pthread_mutexattr_t const   *)((void *)0));
#line 106
  pthread_create(& t[i], (pthread_attr_t const   *)((void *)0), & sort_thread, (void *)0);
#line 106
  i ++;
#line 107
  channel[i] = 0;
#line 107
  minBound[i] = j;
#line 107
  maxBound[i] = (j + 10) - 1;
#line 107
  j += 10;
#line 107
  pthread_mutex_init(& ms[i], (pthread_mutexattr_t const   *)((void *)0));
#line 107
  pthread_create(& t[i], (pthread_attr_t const   *)((void *)0), & sort_thread, (void *)0);
#line 107
  i ++;
#line 110
  if (! (i == 3)) {
#line 110
    __VERIFIER_error();
  }
#line 113
  k = 0;
#line 114
  while (k < 3) {
#line 122
    i = 0;
#line 128
    pthread_mutex_lock(& ms[0]);
#line 128
    if (channel[0] == 1) {
#line 128
      k ++;
    }
#line 128
    pthread_mutex_unlock(& ms[0]);
#line 128
    i = 0 + 1;
#line 129
    pthread_mutex_lock(& ms[i]);
#line 129
    if (channel[i] == 1) {
#line 129
      k ++;
    }
#line 129
    pthread_mutex_unlock(& ms[i]);
#line 129
    i ++;
#line 130
    pthread_mutex_lock(& ms[i]);
#line 130
    if (channel[i] == 1) {
#line 130
      k ++;
    }
#line 130
    pthread_mutex_unlock(& ms[i]);
#line 130
    i ++;
#line 133
    if (! (i == 3)) {
#line 133
      __VERIFIER_error();
    }
  }
#line 138
  if (! (th_id == 3)) {
#line 138
    __VERIFIER_error();
  }
#line 142
  if (! (k == 3)) {
#line 142
    __VERIFIER_error();
  }
#line 20
  _cil10 = 0;
#line 21
  _cil12 = 0;
#line 21
  while (_cil12 < 30) {
#line 23
    _cil14 = _cil12;
#line 23
    while (_cil14 < 30) {
#line 25
      if (source[_cil12] > source[_cil14]) {
#line 27
        _cil10 = source[_cil12];
#line 28
        source[_cil12] = source[_cil14];
#line 29
        source[_cil14] = _cil10;
      }
#line 23
      _cil14 ++;
    }
#line 21
    _cil12 ++;
  }
#line 149
  i = 0;
#line 149
  while (i < 30) {
#line 149
    i ++;
  }
#line 154
  i = 0;
#line 155
  pthread_join(t[0], (void **)((void *)0));
#line 155
  i = 0 + 1;
#line 156
  pthread_join(t[i], (void **)((void *)0));
#line 156
  i ++;
#line 157
  pthread_join(t[i], (void **)((void *)0));
#line 157
  i ++;
#line 159
  if (! (i == 3)) {
#line 159
    __VERIFIER_error();
  }
#line 161
  return (0);
}
}
#line 35 "sorting_3.c"
void *sort_thread(void *arg ) 
{ 
  int _cil13 ;
  int _cil11 ;
  int _cil9 ;
  int id ;
  int x ;
  int y ;

  {
#line 37
  id = -1;
#line 41
  pthread_mutex_lock(& mid);
#line 42
  id = th_id;
#line 43
  th_id ++;
#line 44
  pthread_mutex_unlock(& mid);
#line 47
  x = minBound[id];
#line 48
  y = maxBound[id];
#line 52
  if (! (x >= 0)) {
#line 52
    __VERIFIER_error();
  }
#line 54
  if (! (x < 30)) {
#line 54
    __VERIFIER_error();
  }
#line 56
  if (! (y >= 0)) {
#line 56
    __VERIFIER_error();
  }
#line 58
  if (! (y < 30)) {
#line 58
    __VERIFIER_error();
  }
#line 20
  _cil9 = 0;
#line 21
  _cil11 = x;
#line 21
  while (_cil11 < y) {
#line 23
    _cil13 = _cil11;
#line 23
    while (_cil13 < y) {
#line 25
      if (source[_cil11] > source[_cil13]) {
#line 27
        _cil9 = source[_cil11];
#line 28
        source[_cil11] = source[_cil13];
#line 29
        source[_cil13] = _cil9;
      }
#line 23
      _cil13 ++;
    }
#line 21
    _cil11 ++;
  }
#line 65
  pthread_mutex_lock(& ms[id]);
#line 66
  channel[id] = 1;
#line 67
  pthread_mutex_unlock(& ms[id]);
#line 68
  return ((void *)0);
}
}

/* done: 24 globals */

